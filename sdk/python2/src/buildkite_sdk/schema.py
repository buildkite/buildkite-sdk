# Code generated by the gen package. DO NOT EDIT.
# *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***
from __future__ import annotations
from typing import Union, Literal, List, Dict, Any, Optional, TypedDict, NotRequired
from pydantic import BaseModel, Field

type Agents = Union[AgentsObject,AgentsList]

type AgentsList = List[str]

type AgentsObject = Dict[str, Any]

type AllowDependencyFailure = Literal[True,False,'true','false']

type AllowedTeams = Union[str,List[str]]

AutomaticRetryDict = TypedDict('AutomaticRetryDict',{
	'exit_status': NotRequired[Union[Literal['*'],int,List[int]]],
	'limit': NotRequired['int'],
	'signal': NotRequired['str'],
	'signal_reason': NotRequired[Literal['*','none','agent_refused','agent_stop','cancel','process_run_error','signature_rejected']],
	
})

class AutomaticRetry(BaseModel):
	exit_status: Optional[Union[Literal['*'],int,List[int]]] = None
	limit: Optional[int] = None
	signal: Optional[str] = None
	signal_reason: Optional[Literal['*','none','agent_refused','agent_stop','cancel','process_run_error','signature_rejected']] = None

	@classmethod
	def from_dict(cls, data: AutomaticRetryDict) -> AutomaticRetry:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type AutomaticRetryList = List[Union[AutomaticRetry,AutomaticRetryDict]]

BlockStepDict = TypedDict('BlockStepDict',{
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'allowed_teams': NotRequired['AllowedTeams'],
	'block': NotRequired['str'],
	'blocked_state': NotRequired[Literal['passed','failed','running']],
	'branches': NotRequired['Branches'],
	'depends_on': NotRequired['DependsOn'],
	'fields': NotRequired['Fields'],
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'name': NotRequired['str'],
	'prompt': NotRequired['str'],
	'type': NotRequired[Literal['block']],
	
})

class BlockStep(BaseModel):
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	allowed_teams: Optional[AllowedTeams] = None
	block: Optional[str] = None
	blocked_state: Optional[Literal['passed','failed','running']] = None
	branches: Optional[Branches] = None
	depends_on: Optional[DependsOn] = None
	fields: Optional[Fields] = None
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	key: Optional[str] = None
	label: Optional[str] = None
	name: Optional[str] = None
	prompt: Optional[str] = None
	type: Optional[Literal['block']] = None

	@classmethod
	def from_dict(cls, data: BlockStepDict) -> BlockStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type Branches = Union[str,List[str]]

type BuildNotify = List[Union[NotifySimple,NotifyEmailDict,NotifyEmail,NotifyBasecampDict,NotifyBasecamp,NotifySlackDict,NotifySlack,NotifyWebhookDict,NotifyWebhook,NotifyPagerdutyDict,NotifyPagerduty,NotifyGithubCommitStatusDict,NotifyGithubCommitStatus,NotifyGithubCheckDict,NotifyGithubCheck]]

CacheObjectDict = TypedDict('CacheObjectDict',{
	'name': NotRequired['str'],
	'paths': NotRequired['List[str]'],
	'size': NotRequired['str'],
	
})

class CacheObject(BaseModel):
	name: Optional[str] = None
	paths: Optional[List[str]] = None
	size: Optional[str] = None

	@classmethod
	def from_dict(cls, data: CacheObjectDict) -> CacheObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
type Cache = Union[str,List[str],CacheObject]

type CancelOnBuildFailing = Literal[True,False,'true','false']

class CommandStepRetry(BaseModel):
	automatic: Optional[CommandStepAutomaticRetry] = None
	manual: Optional[CommandStepManualRetry] = None

	@classmethod
	def from_dict(cls, data: CommandStepRetryDict) -> CommandStepRetry:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
CommandStepRetryDict = TypedDict('CommandStepRetryDict',{
	'automatic': NotRequired['CommandStepAutomaticRetry'],
	'manual': NotRequired['CommandStepManualRetry'],
	
})
class CommandStepSignature(BaseModel):
	algorithm: Optional[str] = None
	signed_fields: Optional[List[str]] = None
	value: Optional[str] = None

	@classmethod
	def from_dict(cls, data: CommandStepSignatureDict) -> CommandStepSignature:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
CommandStepSignatureDict = TypedDict('CommandStepSignatureDict',{
	'algorithm': NotRequired['str'],
	'signed_fields': NotRequired['List[str]'],
	'value': NotRequired['str'],
	
})
CommandStepDict = TypedDict('CommandStepDict',{
	'agents': NotRequired['Agents'],
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'artifact_paths': NotRequired['Union[str,List[str]]'],
	'branches': NotRequired['Branches'],
	'cache': NotRequired['Cache'],
	'cancel_on_build_failing': NotRequired['CancelOnBuildFailing'],
	'command': NotRequired['CommandStepCommand'],
	'commands': NotRequired['CommandStepCommand'],
	'concurrency': NotRequired['int'],
	'concurrency_group': NotRequired['str'],
	'concurrency_method': NotRequired[Literal['ordered','eager']],
	'depends_on': NotRequired['DependsOn'],
	'env': NotRequired['Env'],
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'if_changed': NotRequired['str'],
	'image': NotRequired['str'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'matrix': NotRequired['Matrix'],
	'name': NotRequired['str'],
	'notify': NotRequired['CommandStepNotify'],
	'parallelism': NotRequired['int'],
	'plugins': NotRequired['Plugins'],
	'priority': NotRequired['int'],
	'retry': NotRequired['CommandStepRetryDict'],
	'signature': NotRequired['CommandStepSignatureDict'],
	'skip': NotRequired['Skip'],
	'soft_fail': NotRequired['SoftFail'],
	'timeout_in_minutes': NotRequired['int'],
	'type': NotRequired[Literal['script','command','commands']],
	
})

class CommandStep(BaseModel):
	agents: Optional[Agents] = None
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	artifact_paths: Optional[Union[str,List[str]]] = None
	branches: Optional[Branches] = None
	cache: Optional[Cache] = None
	cancel_on_build_failing: Optional[CancelOnBuildFailing] = None
	command: Optional[CommandStepCommand] = None
	commands: Optional[CommandStepCommand] = None
	concurrency: Optional[int] = None
	concurrency_group: Optional[str] = None
	concurrency_method: Optional[Literal['ordered','eager']] = None
	depends_on: Optional[DependsOn] = None
	env: Optional[Env] = None
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	if_changed: Optional[str] = None
	image: Optional[str] = None
	key: Optional[str] = None
	label: Optional[str] = None
	matrix: Optional[Matrix] = None
	name: Optional[str] = None
	notify: Optional[CommandStepNotify] = None
	parallelism: Optional[int] = None
	plugins: Optional[Plugins] = None
	priority: Optional[int] = None
	retry: Optional[CommandStepRetry] = None
	signature: Optional[CommandStepSignature] = None
	skip: Optional[Skip] = None
	soft_fail: Optional[SoftFail] = None
	timeout_in_minutes: Optional[int] = None
	type: Optional[Literal['script','command','commands']] = None

	@classmethod
	def from_dict(cls, data: CommandStepDict) -> CommandStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type CommandStepAutomaticRetry = Union[Literal[True,False,'true','false'],AutomaticRetryDict,AutomaticRetry,AutomaticRetryList]

type CommandStepCommand = Union[List[str],str]

type CommandStepManualRetry = Union[Literal[True,False,'true','false'],CommandStepManualRetryObjectDict,CommandStepManualRetryObject]

CommandStepManualRetryObjectDict = TypedDict('CommandStepManualRetryObjectDict',{
	'allowed': NotRequired[Literal[True,False,'true','false']],
	'permit_on_passed': NotRequired[Literal[True,False,'true','false']],
	'reason': NotRequired['str'],
	
})

class CommandStepManualRetryObject(BaseModel):
	allowed: Optional[Literal[True,False,'true','false']] = None
	permit_on_passed: Optional[Literal[True,False,'true','false']] = None
	reason: Optional[str] = None

	@classmethod
	def from_dict(cls, data: CommandStepManualRetryObjectDict) -> CommandStepManualRetryObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type CommandStepNotify = List[Union[NotifySimple,NotifyBasecampDict,NotifyBasecamp,NotifySlackDict,NotifySlack,NotifyGithubCommitStatusDict,NotifyGithubCommitStatus,NotifyGithubCheckDict,NotifyGithubCheck]]

type DependsOn = Union[str,DependsOnList]

DependsOnListObjectDict = TypedDict('DependsOnListObjectDict',{
	'allow_failure': NotRequired[Literal[True,False,'true','false']],
	'step': NotRequired['str'],
	
})

class DependsOnListObject(BaseModel):
	allow_failure: Optional[Literal[True,False,'true','false']] = None
	step: Optional[str] = None

	@classmethod
	def from_dict(cls, data: DependsOnListObjectDict) -> DependsOnListObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
type DependsOnList = List[Union[str,DependsOnListObject,DependsOnListObjectDict]]

type Env = Dict[str, Any]

type Fields = List[Union[TextFieldDict,TextField,SelectFieldDict,SelectField]]

GroupStepDict = TypedDict('GroupStepDict',{
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'depends_on': NotRequired['DependsOn'],
	'group': 'str',
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'if_changed': NotRequired['str'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'name': NotRequired['str'],
	'notify': NotRequired['BuildNotify'],
	'skip': NotRequired['Skip'],
	'steps': 'GroupSteps',
	
})

class GroupStep(BaseModel):
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	depends_on: Optional[DependsOn] = None
	group: str
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	if_changed: Optional[str] = None
	key: Optional[str] = None
	label: Optional[str] = None
	name: Optional[str] = None
	notify: Optional[BuildNotify] = None
	skip: Optional[Skip] = None
	steps: GroupSteps

	@classmethod
	def from_dict(cls, data: GroupStepDict) -> GroupStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type GroupSteps = List[Union[BlockStepDict,BlockStep,NestedBlockStepDict,NestedBlockStep,StringBlockStep,InputStepDict,InputStep,NestedInputStepDict,NestedInputStep,StringInputStep,CommandStepDict,CommandStep,NestedCommandStepDict,NestedCommandStep,WaitStepDict,WaitStep,NestedWaitStepDict,NestedWaitStep,StringWaitStep,TriggerStepDict,TriggerStep,NestedTriggerStepDict,NestedTriggerStep]]

type If = str

type IfChanged = str

type Image = str

InputStepDict = TypedDict('InputStepDict',{
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'allowed_teams': NotRequired['AllowedTeams'],
	'branches': NotRequired['Branches'],
	'depends_on': NotRequired['DependsOn'],
	'fields': NotRequired['Fields'],
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'input': NotRequired['str'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'name': NotRequired['str'],
	'prompt': NotRequired['str'],
	'type': NotRequired[Literal['input']],
	
})

class InputStep(BaseModel):
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	allowed_teams: Optional[AllowedTeams] = None
	branches: Optional[Branches] = None
	depends_on: Optional[DependsOn] = None
	fields: Optional[Fields] = None
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	input: Optional[str] = None
	key: Optional[str] = None
	label: Optional[str] = None
	name: Optional[str] = None
	prompt: Optional[str] = None
	type: Optional[Literal['input']] = None

	@classmethod
	def from_dict(cls, data: InputStepDict) -> InputStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type Key = str

type Label = str

type Matrix = Union[MatrixElementList,MatrixObjectDict,MatrixObject]

MatrixAdjustmentsDict = TypedDict('MatrixAdjustmentsDict',{
	'skip': NotRequired['Skip'],
	'soft_fail': NotRequired['SoftFail'],
	'with': 'Union[MatrixElementList,MatrixAdjustmentsWithObject]',
	
})

class MatrixAdjustments(BaseModel):
	skip: Optional[Skip] = None
	soft_fail: Optional[SoftFail] = None
	matrix_with: Union[MatrixElementList,MatrixAdjustmentsWithObject] = Field(serialization_alias='with')

	@classmethod
	def from_dict(cls, data: MatrixAdjustmentsDict) -> MatrixAdjustments:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type MatrixAdjustmentsWithObject = Dict[str, str]

type MatrixElement = Union[str,int,bool]

type MatrixElementList = List[Union[str,int,bool]]

MatrixObjectDict = TypedDict('MatrixObjectDict',{
	'adjustments': NotRequired['List[MatrixAdjustmentsDict]'],
	'setup': 'MatrixSetup',
	
})

class MatrixObject(BaseModel):
	adjustments: Optional[List[MatrixAdjustments]] = None
	setup: MatrixSetup

	@classmethod
	def from_dict(cls, data: MatrixObjectDict) -> MatrixObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type MatrixSetupObject = Dict[str, List[Union[str,int,bool]]]
type MatrixSetup = Union[MatrixElementList,Dict[str, List[Union[str,int,bool]]]]

NestedBlockStepDict = TypedDict('NestedBlockStepDict',{
	'block': NotRequired['BlockStepDict'],
	
})

class NestedBlockStep(BaseModel):
	block: Optional[BlockStep] = None

	@classmethod
	def from_dict(cls, data: NestedBlockStepDict) -> NestedBlockStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NestedCommandStepDict = TypedDict('NestedCommandStepDict',{
	'command': NotRequired['CommandStepDict'],
	'commands': NotRequired['CommandStepDict'],
	'script': NotRequired['CommandStepDict'],
	
})

class NestedCommandStep(BaseModel):
	command: Optional[CommandStep] = None
	commands: Optional[CommandStep] = None
	script: Optional[CommandStep] = None

	@classmethod
	def from_dict(cls, data: NestedCommandStepDict) -> NestedCommandStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NestedInputStepDict = TypedDict('NestedInputStepDict',{
	'input': NotRequired['InputStepDict'],
	
})

class NestedInputStep(BaseModel):
	input: Optional[InputStep] = None

	@classmethod
	def from_dict(cls, data: NestedInputStepDict) -> NestedInputStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NestedTriggerStepDict = TypedDict('NestedTriggerStepDict',{
	'trigger': NotRequired['TriggerStepDict'],
	
})

class NestedTriggerStep(BaseModel):
	trigger: Optional[TriggerStep] = None

	@classmethod
	def from_dict(cls, data: NestedTriggerStepDict) -> NestedTriggerStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NestedWaitStepDict = TypedDict('NestedWaitStepDict',{
	'wait': NotRequired['WaitStepDict'],
	'waiter': NotRequired['WaitStepDict'],
	
})

class NestedWaitStep(BaseModel):
	wait: Optional[WaitStep] = None
	waiter: Optional[WaitStep] = None

	@classmethod
	def from_dict(cls, data: NestedWaitStepDict) -> NestedWaitStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifyBasecampDict = TypedDict('NotifyBasecampDict',{
	'basecamp_campfire': NotRequired['str'],
	'if': NotRequired['If'],
	
})

class NotifyBasecamp(BaseModel):
	basecamp_campfire: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)

	@classmethod
	def from_dict(cls, data: NotifyBasecampDict) -> NotifyBasecamp:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifyEmailDict = TypedDict('NotifyEmailDict',{
	'email': NotRequired['str'],
	'if': NotRequired['If'],
	
})

class NotifyEmail(BaseModel):
	email: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)

	@classmethod
	def from_dict(cls, data: NotifyEmailDict) -> NotifyEmail:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifyGithubCheckDict = TypedDict('NotifyGithubCheckDict',{
	'github_check': NotRequired['Dict[str, Any]'],
	
})

class NotifyGithubCheck(BaseModel):
	github_check: Optional[Dict[str, Any]] = None

	@classmethod
	def from_dict(cls, data: NotifyGithubCheckDict) -> NotifyGithubCheck:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

class NotifyGithubCommitStatusGithubCommitStatus(BaseModel):
	context: Optional[str] = None

	@classmethod
	def from_dict(cls, data: NotifyGithubCommitStatusGithubCommitStatusDict) -> NotifyGithubCommitStatusGithubCommitStatus:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
NotifyGithubCommitStatusGithubCommitStatusDict = TypedDict('NotifyGithubCommitStatusGithubCommitStatusDict',{
	'context': NotRequired['str'],
	
})
NotifyGithubCommitStatusDict = TypedDict('NotifyGithubCommitStatusDict',{
	'github_commit_status': NotRequired['NotifyGithubCommitStatusGithubCommitStatusDict'],
	'if': NotRequired['If'],
	
})

class NotifyGithubCommitStatus(BaseModel):
	github_commit_status: Optional[NotifyGithubCommitStatusGithubCommitStatus] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)

	@classmethod
	def from_dict(cls, data: NotifyGithubCommitStatusDict) -> NotifyGithubCommitStatus:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifyPagerdutyDict = TypedDict('NotifyPagerdutyDict',{
	'if': NotRequired['If'],
	'pagerduty_change_event': NotRequired['str'],
	
})

class NotifyPagerduty(BaseModel):
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	pagerduty_change_event: Optional[str] = None

	@classmethod
	def from_dict(cls, data: NotifyPagerdutyDict) -> NotifyPagerduty:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type NotifySimple = Literal['github_check','github_commit_status']

NotifySlackDict = TypedDict('NotifySlackDict',{
	'if': NotRequired['If'],
	'slack': NotRequired['Union[str,NotifySlackObjectDict]'],
	
})

class NotifySlack(BaseModel):
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	slack: Optional[Union[str,NotifySlackObject]] = None

	@classmethod
	def from_dict(cls, data: NotifySlackDict) -> NotifySlack:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifySlackObjectDict = TypedDict('NotifySlackObjectDict',{
	'channels': NotRequired['List[str]'],
	'message': NotRequired['str'],
	
})

class NotifySlackObject(BaseModel):
	channels: Optional[List[str]] = None
	message: Optional[str] = None

	@classmethod
	def from_dict(cls, data: NotifySlackObjectDict) -> NotifySlackObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

NotifyWebhookDict = TypedDict('NotifyWebhookDict',{
	'if': NotRequired['If'],
	'webhook': NotRequired['str'],
	
})

class NotifyWebhook(BaseModel):
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	webhook: Optional[str] = None

	@classmethod
	def from_dict(cls, data: NotifyWebhookDict) -> NotifyWebhook:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type PipelineSteps = List[Union[BlockStepDict,BlockStep,NestedBlockStepDict,NestedBlockStep,StringBlockStep,InputStepDict,InputStep,NestedInputStepDict,NestedInputStep,StringInputStep,CommandStepDict,CommandStep,NestedCommandStepDict,NestedCommandStep,WaitStepDict,WaitStep,NestedWaitStepDict,NestedWaitStep,StringWaitStep,TriggerStepDict,TriggerStep,NestedTriggerStepDict,NestedTriggerStep,GroupStepDict,GroupStep]]

type Plugins = Union[PluginsList,PluginsObject]

type PluginsListObject = Dict[str, Any]
type PluginsList = List[Union[str,Dict[str, Any]]]

type PluginsObject = Dict[str, Any]

type Prompt = str

SelectFieldDict = TypedDict('SelectFieldDict',{
	'default': NotRequired['Union[str,List[str]]'],
	'hint': NotRequired['str'],
	'key': 'str',
	'multiple': NotRequired[Literal[True,False,'true','false']],
	'options': 'List[SelectFieldOptionDict]',
	'required': NotRequired[Literal[True,False,'true','false']],
	'select': NotRequired['str'],
	
})

class SelectField(BaseModel):
	default: Optional[Union[str,List[str]]] = None
	hint: Optional[str] = None
	key: str
	multiple: Optional[Literal[True,False,'true','false']] = None
	options: List[SelectFieldOption]
	required: Optional[Literal[True,False,'true','false']] = None
	select: Optional[str] = None

	@classmethod
	def from_dict(cls, data: SelectFieldDict) -> SelectField:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

SelectFieldOptionDict = TypedDict('SelectFieldOptionDict',{
	'hint': NotRequired['str'],
	'label': 'str',
	'required': NotRequired[Literal[True,False,'true','false']],
	'value': 'str',
	
})

class SelectFieldOption(BaseModel):
	hint: Optional[str] = None
	label: str
	required: Optional[Literal[True,False,'true','false']] = None
	value: str

	@classmethod
	def from_dict(cls, data: SelectFieldOptionDict) -> SelectFieldOption:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type Skip = Union[bool,str]

type SoftFail = Union[Literal[True,False,'true','false'],SoftFailList]

type SoftFailList = List[Union[SoftFailObject,SoftFailObjectDict]]

SoftFailObjectDict = TypedDict('SoftFailObjectDict',{
	'exit_status': NotRequired[Union[Literal['*'],int]],
	
})

class SoftFailObject(BaseModel):
	exit_status: Optional[Union[Literal['*'],int]] = None

	@classmethod
	def from_dict(cls, data: SoftFailObjectDict) -> SoftFailObject:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

type StringBlockStep = Literal['block']

type StringInputStep = Literal['input']

type StringWaitStep = Literal['wait','waiter']

TextFieldDict = TypedDict('TextFieldDict',{
	'default': NotRequired['str'],
	'format': NotRequired['str'],
	'hint': NotRequired['str'],
	'key': 'str',
	'required': NotRequired[Literal[True,False,'true','false']],
	'text': NotRequired['str'],
	
})

class TextField(BaseModel):
	default: Optional[str] = None
	format: Optional[str] = None
	hint: Optional[str] = None
	key: str
	required: Optional[Literal[True,False,'true','false']] = None
	text: Optional[str] = None

	@classmethod
	def from_dict(cls, data: TextFieldDict) -> TextField:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

class TriggerStepBuild(BaseModel):
	branch: Optional[str] = None
	commit: Optional[str] = None
	env: Optional[Env] = None
	message: Optional[str] = None
	meta_data: Optional[Dict[str, Any]] = None

	@classmethod
	def from_dict(cls, data: TriggerStepBuildDict) -> TriggerStepBuild:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})
TriggerStepBuildDict = TypedDict('TriggerStepBuildDict',{
	'branch': NotRequired['str'],
	'commit': NotRequired['str'],
	'env': NotRequired['Env'],
	'message': NotRequired['str'],
	'meta_data': NotRequired['Dict[str, Any]'],
	
})
TriggerStepDict = TypedDict('TriggerStepDict',{
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'async': NotRequired[Literal[True, False, 'true', 'false']],
	'branches': NotRequired['Branches'],
	'build': NotRequired['TriggerStepBuildDict'],
	'depends_on': NotRequired['DependsOn'],
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'if_changed': NotRequired['str'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'name': NotRequired['str'],
	'skip': NotRequired['Skip'],
	'soft_fail': NotRequired['SoftFail'],
	'trigger': 'str',
	'type': NotRequired[Literal['trigger']],
	
})

class TriggerStep(BaseModel):
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	pipeline_async: Optional[Literal[True, False, 'true', 'false']] = Field(serialization_alias='async', default=None)
	branches: Optional[Branches] = None
	build: Optional[TriggerStepBuild] = None
	depends_on: Optional[DependsOn] = None
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	if_changed: Optional[str] = None
	key: Optional[str] = None
	label: Optional[str] = None
	name: Optional[str] = None
	skip: Optional[Skip] = None
	soft_fail: Optional[SoftFail] = None
	trigger: str
	type: Optional[Literal['trigger']] = None

	@classmethod
	def from_dict(cls, data: TriggerStepDict) -> TriggerStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

WaitStepDict = TypedDict('WaitStepDict',{
	'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
	'branches': NotRequired['Branches'],
	'continue_on_failure': NotRequired[Literal[True,False,'true','false']],
	'depends_on': NotRequired['DependsOn'],
	'id': NotRequired['str'],
	'identifier': NotRequired['str'],
	'if': NotRequired['If'],
	'key': NotRequired['str'],
	'label': NotRequired['str'],
	'name': NotRequired['str'],
	'type': NotRequired[Literal['wait','waiter']],
	'wait': NotRequired['str'],
	
})

class WaitStep(BaseModel):
	allow_dependency_failure: Optional[AllowDependencyFailure] = None
	branches: Optional[Branches] = None
	continue_on_failure: Optional[Literal[True,False,'true','false']] = None
	depends_on: Optional[DependsOn] = None
	id: Optional[str] = None
	identifier: Optional[str] = None
	pipeline_if: Optional[If] = Field(serialization_alias='if', default=None)
	key: Optional[str] = None
	label: Optional[str] = None
	name: Optional[str] = None
	type: Optional[Literal['wait','waiter']] = None
	wait: Optional[str] = None

	@classmethod
	def from_dict(cls, data: WaitStepDict) -> WaitStep:
		pipeline_if = {'pipeline_if': data['if']} if 'if' in data else {}
		pipeline_async = {'pipeline_async': data['async']} if 'async' in data else {}
		matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
		return cls.model_validate({**data, **pipeline_if, **pipeline_async, **matrix_with})

