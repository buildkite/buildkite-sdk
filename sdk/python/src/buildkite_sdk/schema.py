# Code generated by the gen package. DO NOT EDIT.
# *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***
from __future__ import annotations
from typing import Union, Literal, List, Dict, Any, Optional, TypedDict, NotRequired
from pydantic import BaseModel, Field

type Agents = Union[AgentsObject,AgentsList]

# Query rules to target specific agents in k=v format
type AgentsList = List[str]

# Query rules to target specific agents
type AgentsObject = Dict[str, Any]

# Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
type AllowDependencyFailure = Literal[True,False,'true','false']

# A list of teams that are permitted to unblock this step, whose values are a list of one or more team slugs or IDs
type AllowedTeams = Union[str,List[str]]

AutomaticRetryArgs = TypedDict('AutomaticRetryArgs',{
    # The exit status number that will cause this job to retry
    'exit_status': NotRequired[Union[Literal['*'],int,List[int]]],
    # The number of times this job can be retried
    'limit': NotRequired['int'],
    # The exit signal, if any, that may be retried
    'signal': NotRequired['str'],
    # The exit signal reason, if any, that may be retried
    'signal_reason': NotRequired[Literal['*','none','agent_refused','agent_stop','cancel','process_run_error','signature_rejected']],
    
})

class AutomaticRetry(BaseModel):
    # The exit status number that will cause this job to retry
    exit_status: Optional[Union[Literal['*'],int,List[int]]] = None
    # The number of times this job can be retried
    limit: Optional[int] = None
    # The exit signal, if any, that may be retried
    signal: Optional[str] = None
    # The exit signal reason, if any, that may be retried
    signal_reason: Optional[Literal['*','none','agent_refused','agent_stop','cancel','process_run_error','signature_rejected']] = None

    @classmethod
    def from_dict(cls, data: AutomaticRetryArgs) -> AutomaticRetry:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

type AutomaticRetryList = List[Union[AutomaticRetry,AutomaticRetryArgs]]

BlockStepArgs = TypedDict('BlockStepArgs',{
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # A list of teams that are permitted to unblock this step, whose values are a list of one or more team slugs or IDs
    'allowed_teams': NotRequired['AllowedTeams'],
    # The label of the block step
    'block': NotRequired['str'],
    # The state that the build is set to when the build is blocked by this block step
    'blocked_state': NotRequired[Literal['passed','failed','running']],
    # Which branches will include this step in their builds
    'branches': NotRequired['Branches'],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # A list of input fields required to be filled out before unblocking the step
    'fields': NotRequired['Fields'],
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # The label of the block step
    'label': NotRequired['str'],
    # The label of the block step
    'name': NotRequired['str'],
    # The instructional message displayed in the dialog box when the unblock step is activated
    'prompt': NotRequired['str'],
    'type': NotRequired[Literal['block']],
    
})

class BlockStep(BaseModel):
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # A list of teams that are permitted to unblock this step, whose values are a list of one or more team slugs or IDs
    allowed_teams: Optional[AllowedTeams] = None
    # The label of the block step
    block: Optional[str] = None
    # The state that the build is set to when the build is blocked by this block step
    blocked_state: Optional[Literal['passed','failed','running']] = None
    # Which branches will include this step in their builds
    branches: Optional[Branches] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # A list of input fields required to be filled out before unblocking the step
    fields: Optional[Fields] = None
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # The label of the block step
    label: Optional[str] = None
    # The label of the block step
    name: Optional[str] = None
    # The instructional message displayed in the dialog box when the unblock step is activated
    prompt: Optional[str] = None
    type: Optional[Literal['block']] = None

    @classmethod
    def from_dict(cls, data: BlockStepArgs) -> BlockStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Which branches will include this step in their builds
type Branches = Union[str,List[str]]

# Array of notification options for this step
type BuildNotify = List[Union[NotifySimple,NotifyEmailArgs,NotifyEmail,NotifyBasecampArgs,NotifyBasecamp,NotifySlackArgs,NotifySlack,NotifyWebhookArgs,NotifyWebhook,NotifyPagerdutyArgs,NotifyPagerduty,NotifyGithubCommitStatusArgs,NotifyGithubCommitStatus,NotifyGithubCheckArgs,NotifyGithubCheck]]

CacheObjectArgs = TypedDict('CacheObjectArgs',{
    'name': NotRequired['str'],
    'paths': NotRequired['List[str]'],
    'size': NotRequired['str'],
    
})

class CacheObject(BaseModel):
    name: Optional[str] = None
    paths: Optional[List[str]] = None
    size: Optional[str] = None

    @classmethod
    def from_dict(cls, data: CacheObjectArgs) -> CacheObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
# The paths for the caches to be used in the step
type Cache = Union[str,List[str],CacheObject]

# Whether to cancel the job as soon as the build is marked as failing
type CancelOnBuildFailing = Literal[True,False,'true','false']

# The conditions for retrying this step.
class CommandStepRetry(BaseModel):
    # Whether to allow a job to retry automatically. If set to true, the retry conditions are set to the default value.
    automatic: Optional[CommandStepAutomaticRetry] = None
    # Whether to allow a job to be retried manually
    manual: Optional[CommandStepManualRetry] = None

    @classmethod
    def from_dict(cls, data: CommandStepRetryArgs) -> CommandStepRetry:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
# The conditions for retrying this step.
CommandStepRetryArgs = TypedDict('CommandStepRetryArgs',{
    # Whether to allow a job to retry automatically. If set to true, the retry conditions are set to the default value.
    'automatic': NotRequired['CommandStepAutomaticRetry'],
    # Whether to allow a job to be retried manually
    'manual': NotRequired['CommandStepManualRetry'],
    
})
# The signature of the command step, generally injected by agents at pipeline upload
class CommandStepSignature(BaseModel):
    # The algorithm used to generate the signature
    algorithm: Optional[str] = None
    # The fields that were signed to form the signature value
    signed_fields: Optional[List[str]] = None
    # The signature value, a JWS compact signature with a detached body
    value: Optional[str] = None

    @classmethod
    def from_dict(cls, data: CommandStepSignatureArgs) -> CommandStepSignature:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
# The signature of the command step, generally injected by agents at pipeline upload
CommandStepSignatureArgs = TypedDict('CommandStepSignatureArgs',{
    # The algorithm used to generate the signature
    'algorithm': NotRequired['str'],
    # The fields that were signed to form the signature value
    'signed_fields': NotRequired['List[str]'],
    # The signature value, a JWS compact signature with a detached body
    'value': NotRequired['str'],
    
})
CommandStepArgs = TypedDict('CommandStepArgs',{
    'agents': NotRequired['Agents'],
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # The glob path/s of artifacts to upload once this step has finished running
    'artifact_paths': NotRequired['Union[str,List[str]]'],
    # Which branches will include this step in their builds
    'branches': NotRequired['Branches'],
    # The paths for the caches to be used in the step
    'cache': NotRequired['Cache'],
    # Whether to cancel the job as soon as the build is marked as failing
    'cancel_on_build_failing': NotRequired['CancelOnBuildFailing'],
    # The commands to run on the agent
    'command': NotRequired['CommandStepCommand'],
    # The commands to run on the agent
    'commands': NotRequired['CommandStepCommand'],
    # The maximum number of jobs created from this step that are allowed to run at the same time. If you use this attribute, you must also define concurrency_group.
    'concurrency': NotRequired['int'],
    # A unique name for the concurrency group that you are creating with the concurrency attribute
    'concurrency_group': NotRequired['str'],
    # Control command order, allowed values are 'ordered' (default) and 'eager'.  If you use this attribute, you must also define concurrency_group and concurrency.
    'concurrency_method': NotRequired[Literal['ordered','eager']],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # Environment variables for this step
    'env': NotRequired['Env'],
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    'if_changed': NotRequired['str'],
    # (Kubernetes stack only) The container image to use for this pipeline or step
    'image': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    'label': NotRequired['str'],
    'matrix': NotRequired['Matrix'],
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    'name': NotRequired['str'],
    # Array of notification options for this step
    'notify': NotRequired['CommandStepNotify'],
    # The number of parallel jobs that will be created based on this step
    'parallelism': NotRequired['int'],
    'plugins': NotRequired['Plugins'],
    # Priority of the job, higher priorities are assigned to agents
    'priority': NotRequired['int'],
    # The conditions for retrying this step.
    'retry': NotRequired['CommandStepRetryArgs'],
    # The signature of the command step, generally injected by agents at pipeline upload
    'signature': NotRequired['CommandStepSignatureArgs'],
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    'skip': NotRequired['Skip'],
    # The conditions for marking the step as a soft-fail.
    'soft_fail': NotRequired['SoftFail'],
    # The number of minutes to time out a job
    'timeout_in_minutes': NotRequired['int'],
    'type': NotRequired[Literal['script','command','commands']],
    
})

class CommandStep(BaseModel):
    agents: Optional[Agents] = None
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # The glob path/s of artifacts to upload once this step has finished running
    artifact_paths: Optional[Union[str,List[str]]] = None
    # Which branches will include this step in their builds
    branches: Optional[Branches] = None
    # The paths for the caches to be used in the step
    cache: Optional[Cache] = None
    # Whether to cancel the job as soon as the build is marked as failing
    cancel_on_build_failing: Optional[CancelOnBuildFailing] = None
    # The commands to run on the agent
    command: Optional[CommandStepCommand] = None
    # The commands to run on the agent
    commands: Optional[CommandStepCommand] = None
    # The maximum number of jobs created from this step that are allowed to run at the same time. If you use this attribute, you must also define concurrency_group.
    concurrency: Optional[int] = None
    # A unique name for the concurrency group that you are creating with the concurrency attribute
    concurrency_group: Optional[str] = None
    # Control command order, allowed values are 'ordered' (default) and 'eager'.  If you use this attribute, you must also define concurrency_group and concurrency.
    concurrency_method: Optional[Literal['ordered','eager']] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # Environment variables for this step
    env: Optional[Env] = None
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    if_changed: Optional[str] = None
    # (Kubernetes stack only) The container image to use for this pipeline or step
    image: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    label: Optional[str] = None
    matrix: Optional[Matrix] = None
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    name: Optional[str] = None
    # Array of notification options for this step
    notify: Optional[CommandStepNotify] = None
    # The number of parallel jobs that will be created based on this step
    parallelism: Optional[int] = None
    plugins: Optional[Plugins] = None
    # Priority of the job, higher priorities are assigned to agents
    priority: Optional[int] = None
    # The conditions for retrying this step.
    retry: Optional[CommandStepRetry] = None
    # The signature of the command step, generally injected by agents at pipeline upload
    signature: Optional[CommandStepSignature] = None
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    skip: Optional[Skip] = None
    # The conditions for marking the step as a soft-fail.
    soft_fail: Optional[SoftFail] = None
    # The number of minutes to time out a job
    timeout_in_minutes: Optional[int] = None
    type: Optional[Literal['script','command','commands']] = None

    @classmethod
    def from_dict(cls, data: CommandStepArgs) -> CommandStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Whether to allow a job to retry automatically. If set to true, the retry conditions are set to the default value.
type CommandStepAutomaticRetry = Union[Literal[True,False,'true','false'],AutomaticRetryArgs,AutomaticRetry,AutomaticRetryList]

# The commands to run on the agent
type CommandStepCommand = Union[List[str],str]

# Whether to allow a job to be retried manually
type CommandStepManualRetry = Union[Literal[True,False,'true','false'],CommandStepManualRetryObjectArgs,CommandStepManualRetryObject]

CommandStepManualRetryObjectArgs = TypedDict('CommandStepManualRetryObjectArgs',{
    # Whether or not this job can be retried manually
    'allowed': NotRequired[Literal[True,False,'true','false']],
    # Whether or not this job can be retried after it has passed
    'permit_on_passed': NotRequired[Literal[True,False,'true','false']],
    # A string that will be displayed in a tooltip on the Retry button in Buildkite. This will only be displayed if the allowed attribute is set to false.
    'reason': NotRequired['str'],
    
})

class CommandStepManualRetryObject(BaseModel):
    # Whether or not this job can be retried manually
    allowed: Optional[Literal[True,False,'true','false']] = None
    # Whether or not this job can be retried after it has passed
    permit_on_passed: Optional[Literal[True,False,'true','false']] = None
    # A string that will be displayed in a tooltip on the Retry button in Buildkite. This will only be displayed if the allowed attribute is set to false.
    reason: Optional[str] = None

    @classmethod
    def from_dict(cls, data: CommandStepManualRetryObjectArgs) -> CommandStepManualRetryObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Array of notification options for this step
type CommandStepNotify = List[Union[NotifySimple,NotifyBasecampArgs,NotifyBasecamp,NotifySlackArgs,NotifySlack,NotifyGithubCommitStatusArgs,NotifyGithubCommitStatus,NotifyGithubCheckArgs,NotifyGithubCheck]]

# The step keys for a step to depend on
type DependsOn = Union[str,DependsOnList]

DependsOnListObjectArgs = TypedDict('DependsOnListObjectArgs',{
    'allow_failure': NotRequired[Literal[True,False,'true','false']],
    'step': NotRequired['str'],
    
})

class DependsOnListObject(BaseModel):
    allow_failure: Optional[Literal[True,False,'true','false']] = None
    step: Optional[str] = None

    @classmethod
    def from_dict(cls, data: DependsOnListObjectArgs) -> DependsOnListObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
type DependsOnList = List[Union[str,DependsOnListObject,DependsOnListObjectArgs]]

# Environment variables for this step
type Env = Dict[str, Any]

# A list of input fields required to be filled out before unblocking the step
type Fields = List[Union[TextFieldArgs,TextField,SelectFieldArgs,SelectField]]

GroupStepArgs = TypedDict('GroupStepArgs',{
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # The name to give to this group of steps
    'group': 'str',
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    'if_changed': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # The name to give to this group of steps
    'label': NotRequired['str'],
    # The name to give to this group of steps
    'name': NotRequired['str'],
    # Array of notification options for this step
    'notify': NotRequired['BuildNotify'],
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    'skip': NotRequired['Skip'],
    # A list of steps
    'steps': 'GroupSteps',
    
})

class GroupStep(BaseModel):
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # The name to give to this group of steps
    group: str
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    if_changed: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # The name to give to this group of steps
    label: Optional[str] = None
    # The name to give to this group of steps
    name: Optional[str] = None
    # Array of notification options for this step
    notify: Optional[BuildNotify] = None
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    skip: Optional[Skip] = None
    # A list of steps
    steps: GroupSteps

    @classmethod
    def from_dict(cls, data: GroupStepArgs) -> GroupStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# A list of steps
type GroupSteps = List[Union[BlockStepArgs,BlockStep,NestedBlockStepArgs,NestedBlockStep,StringBlockStep,InputStepArgs,InputStep,NestedInputStepArgs,NestedInputStep,StringInputStep,CommandStepArgs,CommandStep,NestedCommandStepArgs,NestedCommandStep,WaitStepArgs,WaitStep,NestedWaitStepArgs,NestedWaitStep,StringWaitStep,TriggerStepArgs,TriggerStep,NestedTriggerStepArgs,NestedTriggerStep]]

# A boolean expression that omits the step when false
type If = str

# Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
type IfChanged = str

# (Kubernetes stack only) The container image to use for this pipeline or step
type Image = str

InputStepArgs = TypedDict('InputStepArgs',{
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # A list of teams that are permitted to unblock this step, whose values are a list of one or more team slugs or IDs
    'allowed_teams': NotRequired['AllowedTeams'],
    # The state that the build is set to when the build is blocked by this input step
    'blocked_state': NotRequired[Literal['passed','failed','running']],
    # Which branches will include this step in their builds
    'branches': NotRequired['Branches'],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # A list of input fields required to be filled out before unblocking the step
    'fields': NotRequired['Fields'],
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # The label of the input step
    'input': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # The label of the input step
    'label': NotRequired['str'],
    # The label of the input step
    'name': NotRequired['str'],
    # The instructional message displayed in the dialog box when the unblock step is activated
    'prompt': NotRequired['str'],
    'type': NotRequired[Literal['input']],
    
})

class InputStep(BaseModel):
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # A list of teams that are permitted to unblock this step, whose values are a list of one or more team slugs or IDs
    allowed_teams: Optional[AllowedTeams] = None
    # The state that the build is set to when the build is blocked by this input step
    blocked_state: Optional[Literal['passed','failed','running']] = None
    # Which branches will include this step in their builds
    branches: Optional[Branches] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # A list of input fields required to be filled out before unblocking the step
    fields: Optional[Fields] = None
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # The label of the input step
    input: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # The label of the input step
    label: Optional[str] = None
    # The label of the input step
    name: Optional[str] = None
    # The instructional message displayed in the dialog box when the unblock step is activated
    prompt: Optional[str] = None
    type: Optional[Literal['input']] = None

    @classmethod
    def from_dict(cls, data: InputStepArgs) -> InputStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# A unique identifier for a step, must not resemble a UUID
type Key = str

# The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
type Label = str

type Matrix = Union[MatrixElementList,MatrixObjectArgs,MatrixObject]

# An adjustment to a Build Matrix
MatrixAdjustmentsArgs = TypedDict('MatrixAdjustmentsArgs',{
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    'skip': NotRequired['Skip'],
    # The conditions for marking the step as a soft-fail.
    'soft_fail': NotRequired['SoftFail'],
    'with': 'Union[MatrixElementList,MatrixAdjustmentsWithObject]',
    
})

# An adjustment to a Build Matrix
class MatrixAdjustments(BaseModel):
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    skip: Optional[Skip] = None
    # The conditions for marking the step as a soft-fail.
    soft_fail: Optional[SoftFail] = None
    matrix_with: Union[MatrixElementList,MatrixAdjustmentsWithObject] = Field(serialization_alias='with')

    @classmethod
    def from_dict(cls, data: MatrixAdjustmentsArgs) -> MatrixAdjustments:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Build Matrix dimension element
type MatrixAdjustmentsWithObject = Dict[str, str]

type MatrixElement = Union[str,int,bool]

type MatrixElementList = List[Union[str,int,bool]]

# Configuration for multi-dimension Build Matrix
MatrixObjectArgs = TypedDict('MatrixObjectArgs',{
    # An adjustment to a Build Matrix
    'adjustments': NotRequired['List[MatrixAdjustmentsArgs]'],
    'setup': 'MatrixSetup',
    
})

# Configuration for multi-dimension Build Matrix
class MatrixObject(BaseModel):
    # An adjustment to a Build Matrix
    adjustments: Optional[List[MatrixAdjustments]] = None
    setup: MatrixSetup

    @classmethod
    def from_dict(cls, data: MatrixObjectArgs) -> MatrixObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

type MatrixSetupObject = Dict[str, List[Union[str,int,bool]]]
type MatrixSetup = Union[MatrixElementList,Dict[str, List[Union[str,int,bool]]]]

NestedBlockStepArgs = TypedDict('NestedBlockStepArgs',{
    'block': NotRequired['BlockStepArgs'],
    
})

class NestedBlockStep(BaseModel):
    block: Optional[BlockStep] = None

    @classmethod
    def from_dict(cls, data: NestedBlockStepArgs) -> NestedBlockStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NestedCommandStepArgs = TypedDict('NestedCommandStepArgs',{
    'command': NotRequired['CommandStepArgs'],
    'commands': NotRequired['CommandStepArgs'],
    'script': NotRequired['CommandStepArgs'],
    
})

class NestedCommandStep(BaseModel):
    command: Optional[CommandStep] = None
    commands: Optional[CommandStep] = None
    script: Optional[CommandStep] = None

    @classmethod
    def from_dict(cls, data: NestedCommandStepArgs) -> NestedCommandStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NestedInputStepArgs = TypedDict('NestedInputStepArgs',{
    'input': NotRequired['InputStepArgs'],
    
})

class NestedInputStep(BaseModel):
    input: Optional[InputStep] = None

    @classmethod
    def from_dict(cls, data: NestedInputStepArgs) -> NestedInputStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NestedTriggerStepArgs = TypedDict('NestedTriggerStepArgs',{
    'trigger': NotRequired['TriggerStepArgs'],
    
})

class NestedTriggerStep(BaseModel):
    trigger: Optional[TriggerStep] = None

    @classmethod
    def from_dict(cls, data: NestedTriggerStepArgs) -> NestedTriggerStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NestedWaitStepArgs = TypedDict('NestedWaitStepArgs',{
    'wait': NotRequired['WaitStepArgs'],
    'waiter': NotRequired['WaitStepArgs'],
    
})

class NestedWaitStep(BaseModel):
    wait: Optional[WaitStep] = None
    waiter: Optional[WaitStep] = None

    @classmethod
    def from_dict(cls, data: NestedWaitStepArgs) -> NestedWaitStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifyBasecampArgs = TypedDict('NotifyBasecampArgs',{
    'basecamp_campfire': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    
})

class NotifyBasecamp(BaseModel):
    basecamp_campfire: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)

    @classmethod
    def from_dict(cls, data: NotifyBasecampArgs) -> NotifyBasecamp:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifyEmailArgs = TypedDict('NotifyEmailArgs',{
    'email': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    
})

class NotifyEmail(BaseModel):
    email: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)

    @classmethod
    def from_dict(cls, data: NotifyEmailArgs) -> NotifyEmail:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifyGithubCheckArgs = TypedDict('NotifyGithubCheckArgs',{
    'github_check': NotRequired['Dict[str, Any]'],
    
})

class NotifyGithubCheck(BaseModel):
    github_check: Optional[Dict[str, Any]] = None

    @classmethod
    def from_dict(cls, data: NotifyGithubCheckArgs) -> NotifyGithubCheck:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

class NotifyGithubCommitStatusGithubCommitStatus(BaseModel):
    # GitHub commit status name
    context: Optional[str] = None

    @classmethod
    def from_dict(cls, data: NotifyGithubCommitStatusGithubCommitStatusArgs) -> NotifyGithubCommitStatusGithubCommitStatus:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
NotifyGithubCommitStatusGithubCommitStatusArgs = TypedDict('NotifyGithubCommitStatusGithubCommitStatusArgs',{
    # GitHub commit status name
    'context': NotRequired['str'],
    
})
NotifyGithubCommitStatusArgs = TypedDict('NotifyGithubCommitStatusArgs',{
    'github_commit_status': NotRequired['NotifyGithubCommitStatusGithubCommitStatusArgs'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    
})

class NotifyGithubCommitStatus(BaseModel):
    github_commit_status: Optional[NotifyGithubCommitStatusGithubCommitStatus] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)

    @classmethod
    def from_dict(cls, data: NotifyGithubCommitStatusArgs) -> NotifyGithubCommitStatus:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifyPagerdutyArgs = TypedDict('NotifyPagerdutyArgs',{
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    'pagerduty_change_event': NotRequired['str'],
    
})

class NotifyPagerduty(BaseModel):
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    pagerduty_change_event: Optional[str] = None

    @classmethod
    def from_dict(cls, data: NotifyPagerdutyArgs) -> NotifyPagerduty:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

type NotifySimple = Literal['github_check','github_commit_status']

NotifySlackArgs = TypedDict('NotifySlackArgs',{
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    'slack': NotRequired['Union[str,NotifySlackObjectArgs]'],
    
})

class NotifySlack(BaseModel):
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    slack: Optional[Union[str,NotifySlackObject]] = None

    @classmethod
    def from_dict(cls, data: NotifySlackArgs) -> NotifySlack:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifySlackObjectArgs = TypedDict('NotifySlackObjectArgs',{
    'channels': NotRequired['List[str]'],
    'message': NotRequired['str'],
    
})

class NotifySlackObject(BaseModel):
    channels: Optional[List[str]] = None
    message: Optional[str] = None

    @classmethod
    def from_dict(cls, data: NotifySlackObjectArgs) -> NotifySlackObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

NotifyWebhookArgs = TypedDict('NotifyWebhookArgs',{
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    'webhook': NotRequired['str'],
    
})

class NotifyWebhook(BaseModel):
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    webhook: Optional[str] = None

    @classmethod
    def from_dict(cls, data: NotifyWebhookArgs) -> NotifyWebhook:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# A list of steps
type PipelineSteps = List[Union[BlockStepArgs,BlockStep,NestedBlockStepArgs,NestedBlockStep,StringBlockStep,InputStepArgs,InputStep,NestedInputStepArgs,NestedInputStep,StringInputStep,CommandStepArgs,CommandStep,NestedCommandStepArgs,NestedCommandStep,WaitStepArgs,WaitStep,NestedWaitStepArgs,NestedWaitStep,StringWaitStep,TriggerStepArgs,TriggerStep,NestedTriggerStepArgs,NestedTriggerStep,GroupStepArgs,GroupStep]]

type Plugins = Union[PluginsList,PluginsObject]

type PluginsListObject = Dict[str, Any]
# Array of plugins for this step
type PluginsList = List[Union[str,Dict[str, Any]]]

# A map of plugins for this step. Deprecated: please use the array syntax.
type PluginsObject = Dict[str, Any]

# The instructional message displayed in the dialog box when the unblock step is activated
type Prompt = str

SelectFieldArgs = TypedDict('SelectFieldArgs',{
    # The value of the option(s) that will be pre-selected in the dropdown
    'default': NotRequired['Union[str,List[str]]'],
    # The explanatory text that is shown after the label
    'hint': NotRequired['str'],
    # The meta-data key that stores the field's input
    'key': 'str',
    # Whether more than one option may be selected
    'multiple': NotRequired[Literal[True,False,'true','false']],
    'options': 'List[SelectFieldOptionArgs]',
    # Whether the field is required for form submission
    'required': NotRequired[Literal[True,False,'true','false']],
    # The text input name
    'select': NotRequired['str'],
    
})

class SelectField(BaseModel):
    # The value of the option(s) that will be pre-selected in the dropdown
    default: Optional[Union[str,List[str]]] = None
    # The explanatory text that is shown after the label
    hint: Optional[str] = None
    # The meta-data key that stores the field's input
    key: str
    # Whether more than one option may be selected
    multiple: Optional[Literal[True,False,'true','false']] = None
    options: List[SelectFieldOption]
    # Whether the field is required for form submission
    required: Optional[Literal[True,False,'true','false']] = None
    # The text input name
    select: Optional[str] = None

    @classmethod
    def from_dict(cls, data: SelectFieldArgs) -> SelectField:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

SelectFieldOptionArgs = TypedDict('SelectFieldOptionArgs',{
    # The text displayed directly under the select field’s label
    'hint': NotRequired['str'],
    # The text displayed on the select list item
    'label': 'str',
    # Whether the field is required for form submission
    'required': NotRequired[Literal[True,False,'true','false']],
    # The value to be stored as meta-data
    'value': 'str',
    
})

class SelectFieldOption(BaseModel):
    # The text displayed directly under the select field’s label
    hint: Optional[str] = None
    # The text displayed on the select list item
    label: str
    # Whether the field is required for form submission
    required: Optional[Literal[True,False,'true','false']] = None
    # The value to be stored as meta-data
    value: str

    @classmethod
    def from_dict(cls, data: SelectFieldOptionArgs) -> SelectFieldOption:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Whether this step should be skipped. Passing a string provides a reason for skipping this command
type Skip = Union[bool,str]

# The conditions for marking the step as a soft-fail.
type SoftFail = Union[Literal[True,False,'true','false'],SoftFailList]

type SoftFailList = List[Union[SoftFailObject,SoftFailObjectArgs]]

SoftFailObjectArgs = TypedDict('SoftFailObjectArgs',{
    # The exit status number that will cause this job to soft-fail
    'exit_status': NotRequired[Union[Literal['*'],int]],
    
})

class SoftFailObject(BaseModel):
    # The exit status number that will cause this job to soft-fail
    exit_status: Optional[Union[Literal['*'],int]] = None

    @classmethod
    def from_dict(cls, data: SoftFailObjectArgs) -> SoftFailObject:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Pauses the execution of a build and waits on a user to unblock it
type StringBlockStep = Literal['block']

# Pauses the execution of a build and waits on a user to unblock it
type StringInputStep = Literal['input']

# Waits for previous steps to pass before continuing
type StringWaitStep = Literal['wait','waiter']

TextFieldArgs = TypedDict('TextFieldArgs',{
    # The value that is pre-filled in the text field
    'default': NotRequired['str'],
    # The format must be a regular expression implicitly anchored to the beginning and end of the input and is functionally equivalent to the HTML5 pattern attribute.
    'format': NotRequired['str'],
    # The explanatory text that is shown after the label
    'hint': NotRequired['str'],
    # The meta-data key that stores the field's input
    'key': 'str',
    # Whether the field is required for form submission
    'required': NotRequired[Literal[True,False,'true','false']],
    # The text input name
    'text': NotRequired['str'],
    
})

class TextField(BaseModel):
    # The value that is pre-filled in the text field
    default: Optional[str] = None
    # The format must be a regular expression implicitly anchored to the beginning and end of the input and is functionally equivalent to the HTML5 pattern attribute.
    format: Optional[str] = None
    # The explanatory text that is shown after the label
    hint: Optional[str] = None
    # The meta-data key that stores the field's input
    key: str
    # Whether the field is required for form submission
    required: Optional[Literal[True,False,'true','false']] = None
    # The text input name
    text: Optional[str] = None

    @classmethod
    def from_dict(cls, data: TextFieldArgs) -> TextField:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

# Properties of the build that will be created when the step is triggered
class TriggerStepBuild(BaseModel):
    # The branch for the build
    branch: Optional[str] = None
    # The commit hash for the build
    commit: Optional[str] = None
    # Environment variables for this step
    env: Optional[Env] = None
    # The message for the build (supports emoji)
    message: Optional[str] = None
    # Meta-data for the build
    meta_data: Optional[Dict[str, Any]] = None

    @classmethod
    def from_dict(cls, data: TriggerStepBuildArgs) -> TriggerStepBuild:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})
# Properties of the build that will be created when the step is triggered
TriggerStepBuildArgs = TypedDict('TriggerStepBuildArgs',{
    # The branch for the build
    'branch': NotRequired['str'],
    # The commit hash for the build
    'commit': NotRequired['str'],
    # Environment variables for this step
    'env': NotRequired['Env'],
    # The message for the build (supports emoji)
    'message': NotRequired['str'],
    # Meta-data for the build
    'meta_data': NotRequired['Dict[str, Any]'],
    
})
TriggerStepArgs = TypedDict('TriggerStepArgs',{
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # Whether to continue the build without waiting for the triggered step to complete
    'async': NotRequired[Literal[True, False, 'true', 'false']],
    # Which branches will include this step in their builds
    'branches': NotRequired['Branches'],
    # Properties of the build that will be created when the step is triggered
    'build': NotRequired['TriggerStepBuildArgs'],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    'if_changed': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    'label': NotRequired['str'],
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    'name': NotRequired['str'],
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    'skip': NotRequired['Skip'],
    # The conditions for marking the step as a soft-fail.
    'soft_fail': NotRequired['SoftFail'],
    # The slug of the pipeline to create a build
    'trigger': 'str',
    'type': NotRequired[Literal['trigger']],
    
})

class TriggerStep(BaseModel):
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # Whether to continue the build without waiting for the triggered step to complete
    step_async: Optional[Literal[True, False, 'true', 'false']] = Field(serialization_alias='async', default=None)
    # Which branches will include this step in their builds
    branches: Optional[Branches] = None
    # Properties of the build that will be created when the step is triggered
    build: Optional[TriggerStepBuild] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # Agent-applied attribute: A glob pattern that omits the step from a build if it does not match any files changed in the build.
    if_changed: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    label: Optional[str] = None
    # The label that will be displayed in the pipeline visualisation in Buildkite. Supports emoji.
    name: Optional[str] = None
    # Whether this step should be skipped. Passing a string provides a reason for skipping this command
    skip: Optional[Skip] = None
    # The conditions for marking the step as a soft-fail.
    soft_fail: Optional[SoftFail] = None
    # The slug of the pipeline to create a build
    trigger: str
    type: Optional[Literal['trigger']] = None

    @classmethod
    def from_dict(cls, data: TriggerStepArgs) -> TriggerStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

WaitStepArgs = TypedDict('WaitStepArgs',{
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    'allow_dependency_failure': NotRequired['AllowDependencyFailure'],
    # Which branches will include this step in their builds
    'branches': NotRequired['Branches'],
    # Continue to the next steps, even if the previous group of steps fail
    'continue_on_failure': NotRequired[Literal[True,False,'true','false']],
    # The step keys for a step to depend on
    'depends_on': NotRequired['DependsOn'],
    # A unique identifier for a step, must not resemble a UUID
    'id': NotRequired['str'],
    # A unique identifier for a step, must not resemble a UUID
    'identifier': NotRequired['str'],
    # A boolean expression that omits the step when false
    'if': NotRequired['If'],
    # A unique identifier for a step, must not resemble a UUID
    'key': NotRequired['str'],
    # Waits for previous steps to pass before continuing
    'label': NotRequired['str'],
    # Waits for previous steps to pass before continuing
    'name': NotRequired['str'],
    'type': NotRequired[Literal['wait','waiter']],
    # Waits for previous steps to pass before continuing
    'wait': NotRequired['str'],
    
})

class WaitStep(BaseModel):
    # Whether to proceed with this step and further steps if a step named in the depends_on attribute fails
    allow_dependency_failure: Optional[AllowDependencyFailure] = None
    # Which branches will include this step in their builds
    branches: Optional[Branches] = None
    # Continue to the next steps, even if the previous group of steps fail
    continue_on_failure: Optional[Literal[True,False,'true','false']] = None
    # The step keys for a step to depend on
    depends_on: Optional[DependsOn] = None
    # A unique identifier for a step, must not resemble a UUID
    id: Optional[str] = None
    # A unique identifier for a step, must not resemble a UUID
    identifier: Optional[str] = None
    # A boolean expression that omits the step when false
    step_if: Optional[If] = Field(serialization_alias='if', default=None)
    # A unique identifier for a step, must not resemble a UUID
    key: Optional[str] = None
    # Waits for previous steps to pass before continuing
    label: Optional[str] = None
    # Waits for previous steps to pass before continuing
    name: Optional[str] = None
    type: Optional[Literal['wait','waiter']] = None
    # Waits for previous steps to pass before continuing
    wait: Optional[str] = None

    @classmethod
    def from_dict(cls, data: WaitStepArgs) -> WaitStep:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})

