package utils

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

// {{ range .Imports}}
// 	import {{ if .Wildcard }}* as {{ .WildcardName }}{{ else }}{{{ range .Imports }}{{.}}{{end}}}{{end}} from '{{ .PackageName }}'
// 	{{ end }})

var pythonFileTemplate = `# Code generated by the gen package. DO NOT EDIT.
# *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***
from __future__ import annotations
from typing import Union, Literal, List, Dict, Any, Optional
from pydantic import BaseModel, Field

{{.Contents.String}}
`

type PythonFile struct {
	Name     string
	Contents *codeBlock
}

func (p PythonFile) Write() error {
	tmp := template.Must(template.New("pyfile").Parse(pythonFileTemplate))

	file, err := os.Create(p.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, p)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewPythonFile(
	name string,
	contents *codeBlock,
) PythonFile {
	return PythonFile{
		Name:     name,
		Contents: contents,
	}
}

var pythonClassTemplate = `class {{.Name}}(BaseModel):{{ range .Items}}
	{{.Name}}: {{if eq false .Required }}Optional[{{.Value}}]{{else}}{{.Value}}{{end}}{{end}}`

type PythonClassItem struct {
	Name     string
	Value    string
	Required bool
}

type PythonClass struct {
	Name  string
	Items []PythonClassItem
}

func (p *PythonClass) AddItem(name, value string, required bool) {
	p.Items = append(p.Items, PythonClassItem{
		Name:     name,
		Value:    value,
		Required: required,
	})
}

func (p PythonClass) Write() (string, error) {
	tmp := template.Must(template.New("pyclass").Parse(pythonClassTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, p)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewPythonClass(name string) *PythonClass {
	return &PythonClass{Name: name}
}
