package utils

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
)

// {{ range .Imports}}
// 	import {{ if .Wildcard }}* as {{ .WildcardName }}{{ else }}{{{ range .Imports }}{{.}}{{end}}}{{end}} from '{{ .PackageName }}'
// 	{{ end }})

var pythonFileTemplate = `# Code generated by the gen package. DO NOT EDIT.
# *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***
from __future__ import annotations
import sys

if sys.version_info >= (3, 12):
	from typing import Literal, List, Dict, Any, Optional, TypedDict, NotRequired
else:
	from typing import Literal, List, Dict, Any, Optional, NotRequired

	from typing_extensions import TypedDict

from pydantic import BaseModel, Field

{{.Contents.String}}
`

type PythonFile struct {
	Name     string
	Contents *codeBlock
}

func (p PythonFile) Write() error {
	tmp := template.Must(template.New("pyfile").Parse(pythonFileTemplate))

	file, err := os.Create(p.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, p)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewPythonFile(
	name string,
	contents *codeBlock,
) PythonFile {
	return PythonFile{
		Name:     name,
		Contents: contents,
	}
}

var pythonClassTemplate = `{{if ne "" .Description}}{{printf "# %s\n" .Description}}{{end}}class {{.Name}}(BaseModel):{{ range .Items}}
    {{if ne "" .Description}}{{printf "# %s\n    " .Description}}{{end}}{{.Name}}: {{if eq false .Required }}Optional[{{.Value}}]{{if .Alias}} = Field(serialization_alias='{{.Alias}}'{{if eq false .Required }}, default=None{{end}}){{else}} = None{{end}}{{else}}{{.Value}}{{if .Alias}} = Field(serialization_alias='{{.Alias}}'{{if eq false .Required }}, default=None{{end}}){{end}}{{end}}{{end}}

    @classmethod
    def from_dict(cls, data: {{.Name}}Args) -> {{.Name}}:
        step_if = {'step_if': data['if']} if 'if' in data else {}
        step_async = {'step_async': data['async']} if 'async' in data else {}
        matrix_with = {'matrix_with': data['with']} if 'with' in data else {}
        return cls.model_validate({**data, **step_if, **step_async, **matrix_with})`

var pythonTypedDictTemplate = `{{if ne "" .Description}}{{printf "# %s\n" .Description}}{{end}}{{.Name}} = TypedDict('{{.Name}}',{
    {{ range .Items}}{{if ne "" .Description}}{{printf "# %s\n    " .Description}}{{end}}'{{.Name}}': {{if eq false .Required }}NotRequired[{{.Value}}]{{else}}{{.Value}}{{end}},
    {{end}}
})`

type PythonClassItem struct {
	Name            string
	Description     string
	Alias           string
	Value           string
	ConstructorName string
	Required        bool
	IsObjectArray   bool
}

type PythonClass struct {
	Name        string
	Description string
	Items       []PythonClassItem
}

func (p *PythonClass) AddItem(name, value, constructorName, alias, description string, required, isObjectArray bool) {
	p.Items = append(p.Items, PythonClassItem{
		Name:            name,
		Description:     description,
		Alias:           alias,
		Value:           value,
		ConstructorName: constructorName,
		Required:        required,
		IsObjectArray:   isObjectArray,
	})
}

func (p PythonClass) Write() (string, error) {
	tmp := template.Must(template.New("pyclass").Parse(pythonClassTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, p)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func (p PythonClass) WriteTypedDict() (string, error) {
	tmp := template.Must(template.New("pytypeddict").Parse(pythonTypedDictTemplate))

	data := p
	for i, item := range data.Items {
		if !strings.Contains(item.Value, "Literal") {
			data.Items[i] = PythonClassItem{
				Name:            item.Name,
				Description:     item.Description,
				Alias:           item.Alias,
				Value:           fmt.Sprintf("'%s'", item.Value),
				ConstructorName: item.ConstructorName,
				Required:        item.Required,
				IsObjectArray:   item.IsObjectArray,
			}
			continue
		}
		data.Items[i] = item
	}

	res := &bytes.Buffer{}
	err := tmp.Execute(res, data)
	if err != nil {
		return "", fmt.Errorf("writing out typed dict template: %v", err)
	}

	return res.String(), nil
}

func NewPythonClass(name, description string) *PythonClass {
	return &PythonClass{
		Name:        name,
		Description: description,
	}
}
