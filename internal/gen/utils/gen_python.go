package utils

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

// {{ range .Imports}}
// 	import {{ if .Wildcard }}* as {{ .WildcardName }}{{ else }}{{{ range .Imports }}{{.}}{{end}}}{{end}} from '{{ .PackageName }}'
// 	{{ end }})

var pythonFileTemplate = `# Code generated by the gen package. DO NOT EDIT.
# *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***
from __future__ import annotations
from typing import Union, Literal, List, Dict, Any, Optional, TypedDict, NotRequired
from pydantic import BaseModel, Field

{{.Contents.String}}
`

type PythonFile struct {
	Name     string
	Contents *codeBlock
}

func (p PythonFile) Write() error {
	tmp := template.Must(template.New("pyfile").Parse(pythonFileTemplate))

	file, err := os.Create(p.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, p)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewPythonFile(
	name string,
	contents *codeBlock,
) PythonFile {
	return PythonFile{
		Name:     name,
		Contents: contents,
	}
}

var pythonClassTemplate = `class {{.Name}}(BaseModel):{{ range .Items}}
	{{.Name}}: {{if eq false .Required }}Optional[{{.Value}}]{{if .Alias}} = Field(serialization_alias='{{.Alias}}'){{else}} = None{{end}}{{else}}{{.Value}}{{if .Alias}} = Field(serialization_alias='{{.Alias}}'){{end}}{{end}}{{end}}

	@classmethod
	def from_dict(cls, data: {{.Name}}Dict) -> {{.Name}}:
	    return cls(
			{{range .Items}}{{.Name}}={{if .ConstructorName}}{{.ConstructorName}}.from_dict(data['{{.Name}}']){{else}}data['{{.Name}}']{{end}}{{if eq false .Required }} if '{{.Name}}' in data else None{{end}},
			{{end}}
		)`

var pythonTypedDictTemplate = `class {{.Name}}(TypedDict):{{ range .Items}}
	{{.Name}}: {{if eq false .Required }}NotRequired[{{.Value}}]{{else}}{{.Value}}{{end}}{{end}}`

type PythonClassItem struct {
	Name            string
	Alias           string
	Value           string
	ConstructorName string
	Required        bool
}

type PythonClass struct {
	Name  string
	Items []PythonClassItem
}

func (p *PythonClass) AddItem(name, value, constructorName, alias string, required bool) {
	p.Items = append(p.Items, PythonClassItem{
		Name:            name,
		Alias:           alias,
		Value:           value,
		ConstructorName: constructorName,
		Required:        required,
	})
}

func (p PythonClass) Write() (string, error) {
	tmp := template.Must(template.New("pyclass").Parse(pythonClassTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, p)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func (p PythonClass) WriteTypedDict() (string, error) {
	tmp := template.Must(template.New("pytypeddict").Parse(pythonTypedDictTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, p)
	if err != nil {
		return "", fmt.Errorf("writing out typed dict template: %v", err)
	}

	return res.String(), nil
}

func NewPythonClass(name string) *PythonClass {
	return &PythonClass{Name: name}
}

var pythonDictToClassTemplate = `def {{.Name}}(args: {{.ArgsType}}) -> {{.ReturnType}}:
	return {{.ReturnType}}(
		{{range .Items}}{{.Name}}={{if .ConstructorName}}{{.ConstructorName}}(args.get('{{.Name}}', {})){{else}}args.get('{{.Name}}', None){{end}},
		{{end}}
	)`

type PythonDictToClassFunctionItem struct {
	Name            string
	ConstructorName string
}

type PythonDictToClassFunction struct {
	Name       string
	ReturnType string
	ArgsType   string
	Items      []PythonDictToClassFunctionItem
}

func (p *PythonDictToClassFunction) AddItem(name, constructorName string) {
	p.Items = append(p.Items, PythonDictToClassFunctionItem{
		Name:            name,
		ConstructorName: constructorName,
	})
}

func (p PythonDictToClassFunction) Write() (string, error) {
	tmp := template.Must(template.New("pytypeddicttoclass").Parse(pythonDictToClassTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, p)
	if err != nil {
		return "", fmt.Errorf("writing out typed dict template: %v", err)
	}

	return res.String(), nil
}

func NewPythonDictToClassFunction(name, argsType, returnType string) *PythonDictToClassFunction {
	return &PythonDictToClassFunction{
		Name:       name,
		ArgsType:   argsType,
		ReturnType: returnType,
	}
}
