package utils

import (
	"bytes"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"

	"github.com/iancoleman/orderedmap"
)

type FileWriter interface {
	Write() error
}

// File
var goFileTemplate = `// Code generated by the gen package. DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package {{.PackageName}}

import({{ range .Imports}}
    "{{.}}"
{{ end }})

{{.Contents.String}}
`

type GoFile struct {
	PackageName string
	Name        string
	Imports     []string
	Contents    *codeBlock
}

func (g GoFile) Write() error {
	tmp := template.Must(template.New("file").Parse(goFileTemplate))

	file, err := os.Create(g.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, g)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewGoFile(packageName, name string, imports []string, contents *codeBlock) GoFile {
	return GoFile{
		PackageName: packageName,
		Name:        name,
		Imports:     imports,
		Contents:    contents,
	}
}

// Struct
var goStructTemplate = `{{if ne "" .Description}}{{printf "// %s\n" .Description}}{{end}}type {{.Name}} struct { {{ range .Items}}{{printf "\n"}}` +
	`    {{if ne "" .Description}}{{printf "// %s    \n" .Description}}{{end}}` + "{{ .Name }} {{if .Pointer}}*{{end}}{{ .Value }} {{if .TagName}}`json:\"{{.TagName}},omitempty\"`{{end}}" +
	"{{end}}\n}"

type GoStructItem struct {
	Name        string
	Description string
	Value       string
	Pointer     bool
	TagName     string
}

type goStructTemplateArgs struct {
	Name        string
	Description string
	Items       []GoStructItem
}

type GoStruct struct {
	Name        string
	Description string
	Items       *orderedmap.OrderedMap
}

func (g *GoStruct) AddItem(key, val, tagName, description string, isPointer bool) {
	g.Items.Set(key, GoStructItem{
		Name:        key,
		Description: description,
		Value:       val,
		Pointer:     isPointer,
		TagName:     tagName,
	})
}

func (g GoStruct) Write() (string, error) {
	tmp := template.Must(template.New("struct").Parse(goStructTemplate))

	res := &bytes.Buffer{}

	g.Items.SortKeys(sort.Strings)
	keys := g.Items.Keys()
	items := make([]GoStructItem, len(keys))
	for i, key := range keys {
		item, _ := g.Items.Get(key)
		items[i] = item.(GoStructItem)
	}

	err := tmp.Execute(res, goStructTemplateArgs{
		Name:        g.Name,
		Description: g.Description,
		Items:       items,
	})
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewGoStruct(name, description string, items []GoStructItem) *GoStruct {
	return &GoStruct{
		Name:        name,
		Description: description,
		Items:       orderedmap.New(),
	}
}

// Constraint Interface
var goConstraintInterfaceTemplate = `{{if ne "" .Description}}{{printf "// %s\n" .Description}}{{end}}type {{.Name}} interface {
	{{.Items}}
}`

type GoConstraintInterface struct {
	Name        string
	Description string
	Items       []string
}

func (g *GoConstraintInterface) AddItem(item string) {
	g.Items = append(g.Items, item)
}

func (g *GoConstraintInterface) Write() (string, error) {
	tmp := template.Must(template.New("interface").Parse(goConstraintInterfaceTemplate))
	args := struct {
		Name        string
		Description string
		Items       string
	}{
		Name:        g.Name,
		Description: g.Description,
		Items:       strings.Join(g.Items, " | "),
	}

	res := &bytes.Buffer{}
	err := tmp.Execute(res, args)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewGoConstraintInterface(name, description string) *GoConstraintInterface {
	return &GoConstraintInterface{
		Name:        name,
		Description: description,
	}
}
