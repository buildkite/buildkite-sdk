package utils

import (
	"bytes"
	"fmt"
	"os"
	"strings"
	"text/template"
)

// File
var goFileTemplate = `// Code generated by the gen package. DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package {{.PackageName}}

import({{ range .Imports}}
    "{{.}}"
{{ end }})

{{.Contents.String}}
`

type GoFile struct {
	PackageName string
	Name        string
	Imports     []string
	Contents    *codeBlock
}

func (g GoFile) Write() error {
	tmp := template.Must(template.New("file").Parse(goFileTemplate))

	file, err := os.Create(g.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, g)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewGoFile(packageName, name string, imports []string, contents *codeBlock) GoFile {
	return GoFile{
		PackageName: packageName,
		Name:        name,
		Imports:     imports,
		Contents:    contents,
	}
}

// Struct
var goStructTemplate = "type {{.Name}} struct { {{ range .Items}}\n" +
	"    {{ .Name }}  {{if .Pointer}}*{{end}}{{ .Value }} {{if .TagName}}`json:\"{{.TagName}},omitempty\"`{{end}}" +
	"{{end}}\n}"

type GoStructItem struct {
	Name    string
	Value   string
	Pointer bool
	TagName string
}

type GoStruct struct {
	Name  string
	Items []GoStructItem
}

func (g *GoStruct) AddItem(key, val, tagName string, isPointer bool) {
	g.Items = append(g.Items, GoStructItem{
		Name:    key,
		Value:   val,
		Pointer: isPointer,
		TagName: tagName,
	})
}

func (g GoStruct) Write() (string, error) {
	tmp := template.Must(template.New("struct").Parse(goStructTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, g)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewGoStruct(name string, items []GoStructItem) *GoStruct {
	return &GoStruct{
		Name:  name,
		Items: items,
	}
}

// Constraint Interface
var goConstraintInterfaceTemplate = `type {{.Name}} interface {
	{{.Items}}
}`

type GoConstraintInterface struct {
	Name  string
	Items []string
}

func (g *GoConstraintInterface) AddItem(item string) {
	g.Items = append(g.Items, item)
}

func (g *GoConstraintInterface) Write() (string, error) {
	tmp := template.Must(template.New("interface").Parse(goConstraintInterfaceTemplate))
	args := struct {
		Name  string
		Items string
	}{
		Name:  g.Name,
		Items: strings.Join(g.Items, " | "),
	}

	res := &bytes.Buffer{}
	err := tmp.Execute(res, args)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewGoConstraintInterface(name string) *GoConstraintInterface {
	return &GoConstraintInterface{Name: name}
}
