package utils

import (
	"bytes"
	"fmt"
	"os"
	"text/template"
)

// {{ range .Imports}}
// 	import {{ if .Wildcard }}* as {{ .WildcardName }}{{ else }}{{{ range .Imports }}{{.}}{{end}}}{{end}} from '{{ .PackageName }}'
// 	{{ end }})

var tsFileTemplate = `// Code generated by the gen package. DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

{{.Contents.String}}
`

type TypeScriptFileImports struct {
	Wildcard     bool
	WildcardName string
	Imports      []string
	PackageName  string
}

type TypeScriptFile struct {
	Imports  []TypeScriptFileImports
	Name     string
	Contents *codeBlock
}

func (t TypeScriptFile) Write() error {
	tmp := template.Must(template.New("file").Parse(tsFileTemplate))

	file, err := os.Create(t.Name)
	if err != nil {
		return fmt.Errorf("creating file: %v", err)
	}
	defer file.Close()

	err = tmp.Execute(file, t)
	if err != nil {
		return fmt.Errorf("writing file: %v", err)
	}

	return nil
}

func NewTypeScriptFile(
	name string,
	imports []TypeScriptFileImports,
	contents *codeBlock,
) TypeScriptFile {
	return TypeScriptFile{
		Name:     name,
		Imports:  imports,
		Contents: contents,
	}
}

// Interface
var tsInterfaceTemplate = `export interface {{.Name}} { {{ range .Items}}
	{{.Name}}{{if eq false .Required }}?{{end}}: {{.Value}}
{{end}}}`

var tsUnionObjectTemplate = `{ {{ range .Items}}
	{{.Name}}{{if eq false .Required }}?{{end}}: {{.Value}}
{{end}}}`

type TypeScriptInterfaceItem struct {
	Name     string
	Value    string
	Required bool
}

type TypeScriptInterface struct {
	Name  string
	Items []TypeScriptInterfaceItem
}

func (t *TypeScriptInterface) AddItem(name, value string, required bool) {
	t.Items = append(t.Items, TypeScriptInterfaceItem{
		Name:     name,
		Value:    value,
		Required: required,
	})
}

func (t TypeScriptInterface) Write() (string, error) {
	tmp := template.Must(template.New("tsinterface").Parse(tsInterfaceTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, t)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func (t TypeScriptInterface) WriteUnionObject() (string, error) {
	tmp := template.Must(template.New("tsinterfaceUnion").Parse(tsUnionObjectTemplate))

	res := &bytes.Buffer{}
	err := tmp.Execute(res, t)
	if err != nil {
		return "", fmt.Errorf("writing out template: %v", err)
	}

	return res.String(), nil
}

func NewTypeScriptInterface(name string) *TypeScriptInterface {
	return &TypeScriptInterface{Name: name}
}
